<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Event Overlay</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: transparent;
            overflow: hidden;
            position: relative;
        }

        /* Transparent background for OBS */
        .transparent-bg {
            background: transparent !important;
            pointer-events: none;
        }

        /* Alert overlay container */
        .alert-overlay {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100vw;
        }

        /* Custom alert message styles */
        .custom-alert {
            transform: translateY(0);
            transition: all 0.3s ease;
        }

        /* Legacy follow alert for backward compatibility */
        .follow-alert {
            background: linear-gradient(135deg, #c084fc 0%, #9333ea 100%);
            color: white;
            padding: 2rem 3rem;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(147, 51, 234, 0.5);
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            animation: fadeIn 5s ease-in, fadeOut 5s ease-out 5s;
            opacity: 0;
            white-space: nowrap;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        @keyframes alertSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes alertSlideOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* Loading state */
        .loading {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(192, 132, 252, 0.6);
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 10px;
            height: 10px;
            margin-left: 8px;
            border: 2px solid rgba(192, 132, 252, 0.6);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error state */
        .error {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #ef4444;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            max-width: 400px;
        }

        /* Success state */
        .connected {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #22c55e;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .connected::before {
            content: 'âœ“ ';
            margin-right: 4px;
        }

    </style>
</head>
<body class="transparent-bg">
    <!-- Alert Overlay Container -->
    <div class="alert-overlay" id="alertOverlay"></div>
    <!-- Video Overlay Container -->
    <div class="alert-overlay" id="videoOverlay" style="z-index: 2000;"></div>

    <!-- Status Indicator -->
    <div class="loading" id="statusIndicator">Waiting for events...</div>


    <script>
        // Test function accessible from console
        window.testAlert = function(name = 'TestUser') {
            // This will be set by the module after it loads
            if (window.showTestAlert) {
                window.showTestAlert(name);
            } else {
                console.error('showTestAlert not available yet. Wait for page to load.');
            }
        };
    </script>

    <script type="module">
        import { db, collection, query, where, getDocs, onSnapshot } from '/src/firebase.js';
        import '/src/config.js';

        // Initialize event listeners
        let unsubscribeEvents = null;
        let currentUserId = null;

        // Extract userId from URL hash
        function getUserIdFromHash() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#')) {
                const userId = hash.substring(1); // Remove the # symbol
                console.log('Extracted user ID from hash:', userId);
                return userId;
            }
            console.log('No user ID found in URL hash. Expected format: #userId');
            return null;
        }

        // Initialize the overlay
        async function initializeOverlay() {
            const statusIndicator = document.getElementById('statusIndicator');
            
            // Get userId from hash
            currentUserId = getUserIdFromHash();
            
            if (!currentUserId) {
                statusIndicator.textContent = 'No user ID found in URL hash';
                statusIndicator.className = 'error';
                return;
            }
            
            statusIndicator.textContent = 'Connecting...';
            statusIndicator.className = 'loading';
            
            try {
                await loadUserProjects();
                statusIndicator.textContent = 'Connected - Waiting for events';
                statusIndicator.className = 'connected';
            } catch (error) {
                console.error('Error loading projects:', error);
                statusIndicator.textContent = 'Error: ' + error.message;
                statusIndicator.className = 'error';
            }
        }

        // Cleanup function
        function cleanup() {
            if (unsubscribeEvents) {
                unsubscribeEvents.forEach(unsubscribe => {
                    if (typeof unsubscribe === 'function') {
                        unsubscribe();
                    }
                });
                unsubscribeEvents = null;
            }
        }

        // Initialize on page load
        initializeOverlay();

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);

        // Store project configurations for alert customization
        let projectConfigs = new Map();
        // Map of eventType -> array of video URLs
        let eventVideoCache = new Map();
        // Map of eventType -> array of preloaded HTMLVideoElements (detached)
        let preloadedVideoElements = new Map();

        // Load user's active projects from Firestore
        async function loadUserProjects() {
            if (!currentUserId) return;

            try {
                // Clean up existing listeners
                cleanup();

                // Query active Twitch projects
                const projectsRef = collection(db, 'projects');
                const q = query(
                    projectsRef,
                    where('userId', '==', currentUserId),
                    where('platform', '==', 'twitch'),
                    where('twitchSubscription', '==', true)
                );

                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    console.log('No active projects found for user:', currentUserId);
                    const statusIndicator = document.getElementById('statusIndicator');
                    statusIndicator.textContent = 'No active projects found';
                    statusIndicator.className = 'error';
                    return;
                }

                // Store project configurations and build video cache
                eventVideoCache = new Map();
                // Debug: list projects
                const debugProjectsList = [];
                snapshot.docs.forEach(doc => {
                    const projectData = doc.data();
                    const eventType = projectData.eventType;

                    // Store the alert configuration for this event type
                    if (projectData.alertConfig && projectData.alertConfig[eventType]) {
                        projectConfigs.set(eventType, projectData.alertConfig[eventType]);
                        console.log(`Loaded alert config for ${eventType}:`, projectData.alertConfig[eventType]);
                    } else {
                        // Fallback to default configuration
                        projectConfigs.set(eventType, getDefaultAlertConfig(eventType));
                    }

                    // Collect Heygen video URL if available
                    const videoUrl = extractHeygenVideoUrl(projectData);
                    debugProjectsList.push({
                        projectId: doc.id,
                        eventType,
                        heygenVideoId: projectData.heygenVideoId || null,
                        hasVideoUrl: !!videoUrl,
                        videoUrl: videoUrl || null,
                        twitchSubscription: projectData.twitchSubscription,
                        isActive: projectData.isActive
                    });
                    if (videoUrl) {
                        if (!eventVideoCache.has(eventType)) eventVideoCache.set(eventType, []);
                        eventVideoCache.get(eventType).push({
                            projectId: doc.id,
                            videoUrl
                        });
                    } else {
                        const hasHeygenId = !!projectData.heygenVideoId;
                        if (!hasHeygenId) {
                            console.warn(`Project ${doc.id} (${eventType}) missing HeyGen video ID and video URL`);
                        } else {
                            console.warn(`Project ${doc.id} (${eventType}) has HeyGen ID but no resolvable video URL yet`);
                        }
                    }
                });
                console.groupCollapsed(`Loading projects for user ${currentUserId}`);
                try {
                    console.table(debugProjectsList);
                } finally {
                    console.groupEnd();
                }

                // Preload videos for all event types
                preloadAllEventVideos();

                // Get event types to listen for
                const eventTypes = [...new Set(snapshot.docs.map(doc => doc.data().eventType))];
                console.log('Active projects found:', snapshot.size);
                console.log('Event types to monitor:', eventTypes);
                console.log('User ID from hash:', currentUserId);
                console.log('Project configurations loaded:', projectConfigs.size);

                // Set up listeners for each event type
                for (const eventType of eventTypes) {
                    setupEventListener(eventType);
                }

            } catch (error) {
                console.error('Error loading projects:', error);
                throw error;
            }
        }

        // Try to extract a Heygen video URL from a project document
        function extractHeygenVideoUrl(projectData) {
            // Preferred explicit field
            if (projectData.videoUrl && typeof projectData.videoUrl === 'string') {
                return projectData.videoUrl;
            }
            // If wizard stored full heygen response object
            const dataObj = projectData.heygenVideoData || projectData.heygen || projectData.heygenData || null;
            const possibleUrl = dataObj?.data?.video_url || dataObj?.video_url;
            if (possibleUrl && typeof possibleUrl === 'string') {
                return possibleUrl;
            }
            return null;
        }

        // Preload all videos into detached video elements to warm cache
        function preloadAllEventVideos() {
            preloadedVideoElements = new Map();
            eventVideoCache.forEach((items, eventType) => {
                console.groupCollapsed(`Preloading videos for ${eventType}`);
                const list = [];
                items.forEach(item => {
                    try {
                        const v = document.createElement('video');
                        v.src = item.videoUrl;
                        v.preload = 'auto';
                        v.muted = true; // allow autoplay preloading
                        // Start loading
                        v.load();
                        list.push({ projectId: item.projectId, el: v, url: item.videoUrl });
                        console.log('Preloading URL:', item.videoUrl, 'projectId:', item.projectId);
                    } catch (e) {
                        console.warn('Failed to preload video', item.videoUrl, e);
                    }
                });
                preloadedVideoElements.set(eventType, list);
                console.groupEnd();
            });
            console.log('Preloaded Heygen videos by event type:',
                Array.from(eventVideoCache.entries()).reduce((acc, [k, v]) => ({...acc, [k]: v.length}), {}));
        }

        // Get default alert configuration for an event type
        function getDefaultAlertConfig(eventType) {
            const defaults = {
                'channel.follow': {
                    enabled: true,
                    message: '{username} just followed!',
                    backgroundColor: '#c084fc',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                },
                'channel.subscribe': {
                    enabled: true,
                    message: '{username} just subscribed!',
                    backgroundColor: '#22c55e',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                },
                'channel.cheer': {
                    enabled: true,
                    message: '{username} cheered {bits} bits!',
                    backgroundColor: '#f59e0b',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                },
                'channel.raid': {
                    enabled: true,
                    message: '{username} is raiding with {viewers} viewers!',
                    backgroundColor: '#ef4444',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                }
            };
            
            return defaults[eventType] || defaults['channel.follow'];
        }

        // Set up real-time listener for specific event type
        function setupEventListener(eventType) {
            const eventsRef = collection(db, 'users', currentUserId, 'events', `twitch_${eventType}`, 'alerts');
            
            // Query only events after current timestamp
            const now = new Date();
            const q = query(eventsRef, where('timestamp', '>', now));
            
            const unsubscribe = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const alertData = change.doc.data();
                        console.log('New alert received:', alertData);
                        // Try to play Heygen video for this event; fallback to text alert
                        const played = playHeygenVideoForEvent(eventType);
                        if (!played) {
                            showAlert(alertData);
                        }
                    }
                });
            }, (error) => {
                console.error('Error listening to events:', error);
            });

            // Store unsubscribe function for cleanup
            if (!unsubscribeEvents) {
                unsubscribeEvents = [];
            }
            unsubscribeEvents.push(unsubscribe);
        }

        // Play a random preloaded Heygen video for the given event type
        function playHeygenVideoForEvent(eventType) {
            const items = eventVideoCache.get(eventType) || [];
            if (!items.length) {
                console.log(`No Heygen videos cached for event type: ${eventType}`);
                return false;
            }

            const randomIndex = Math.floor(Math.random() * items.length);
            const selected = items[randomIndex];

            const overlay = document.getElementById('videoOverlay');
            // Clear any existing video
            overlay.innerHTML = '';

            // Use preloaded element if available (clone to keep cache warm)
            const preloadedList = preloadedVideoElements.get(eventType) || [];
            const preloadedEntry = preloadedList.find(x => x.url === selected.videoUrl);
            const video = document.createElement('video');
            video.src = selected.videoUrl;
            video.autoplay = true;
            video.controls = false;
            video.playsInline = true;
            video.muted = false; // attempt to play with sound in OBS
            video.style.maxWidth = '90vw';
            video.style.maxHeight = '90vh';
            video.style.borderRadius = '12px';
            video.style.boxShadow = '0 10px 40px rgba(0,0,0,0.5)';
            video.style.pointerEvents = 'none';

            // Fallback: if autoplay with sound blocked, retry muted
            const tryPlay = async () => {
                try {
                    await video.play();
                } catch (err) {
                    console.warn('Autoplay blocked, retrying muted', err);
                    try {
                        video.muted = true;
                        await video.play();
                    } catch (err2) {
                        console.error('Video play failed', err2);
                    }
                }
            };

            overlay.appendChild(video);
            // If we had a preloaded element, help the browser by priming with currentTime
            if (preloadedEntry?.el?.readyState >= 2) {
                // do nothing special; browser cache should already be warm
            }
            // Remove when finished or on error
            const cleanupVideo = () => {
                if (video && video.parentNode) {
                    video.parentNode.removeChild(video);
                }
            };
            video.addEventListener('ended', cleanupVideo, { once: true });
            video.addEventListener('error', () => {
                console.error('Error during video playback for', eventType, selected.videoUrl);
                cleanupVideo();
            }, { once: true });

            // Start playback
            tryPlay();
            return true;
        }

        // Display alert on screen
        function showAlert(alertData) {
            const { eventType, eventData } = alertData;
            
            // Get the configuration for this event type
            const config = projectConfigs.get(eventType) || getDefaultAlertConfig(eventType);
            
            // Skip if disabled
            if (!config.enabled) {
                console.log(`Alert disabled for event type: ${eventType}`);
                return;
            }
            
            // Build message from template
            let message = config.message;
            
            // Replace placeholders with actual data
            message = message.replace('{username}', eventData.user_name || eventData.from_broadcaster_user_name || 'Someone');
            
            // Handle event-specific placeholders
            if (eventType === 'channel.cheer') {
                message = message.replace('{bits}', eventData.bits || '0');
            } else if (eventType === 'channel.raid') {
                message = message.replace('{viewers}', eventData.viewers || '0');
            }

            console.log(`Showing alert: ${message} (${eventType})`);

            // Create alert element
            const alertOverlay = document.getElementById('alertOverlay');
            const alertElement = document.createElement('div');
            
            // Apply custom styling
            alertElement.className = 'custom-alert';
            alertElement.textContent = message;
            alertElement.style.cssText = `
                background: ${config.backgroundColor};
                color: ${config.textColor};
                font-size: ${config.fontSize};
                font-weight: ${config.fontWeight};
                padding: 1.5rem 2.5rem;
                border-radius: 16px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
                text-align: center;
                animation: alertSlideIn 0.5s ease-out, alertSlideOut 0.5s ease-in ${config.duration - 500}ms;
                opacity: 1;
                white-space: nowrap;
                font-family: 'Orbitron', sans-serif;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                position: relative;
                z-index: 1000;
                max-width: 90vw;
                word-wrap: break-word;
                white-space: normal;
            `;
            
            // Position the alert
            if (config.position === 'top') {
                alertOverlay.style.top = '10%';
                alertOverlay.style.bottom = 'auto';
            } else {
                alertOverlay.style.top = 'auto';
                alertOverlay.style.bottom = '10%';
            }
            
            // Clear any existing alerts
            alertOverlay.innerHTML = '';
            alertOverlay.appendChild(alertElement);
            
            // Remove alert after specified duration
            setTimeout(() => {
                if (alertElement.parentNode) {
                    alertElement.parentNode.removeChild(alertElement);
                }
            }, config.duration);
        }

        // Expose functions to window for console access
        window.showTestAlert = function(name = 'TestUser', eventType = 'channel.follow') {
            console.log(`Testing alert with name: ${name}, event: ${eventType}`);
            
            let eventData = {
                user_name: name,
                user_id: '123456',
                broadcaster_user_id: '11867613'
            };
            
            // Add event-specific data
            if (eventType === 'channel.cheer') {
                eventData.bits = Math.floor(Math.random() * 1000) + 1;
            } else if (eventType === 'channel.raid') {
                eventData.viewers = Math.floor(Math.random() * 100) + 1;
            }
            
            const testData = {
                eventType: eventType,
                eventData: eventData
            };
            // Try to play Heygen video for this event type first; fallback to text alert
            const played = playHeygenVideoForEvent(eventType);
            if (!played) {
                showAlert(testData);
            }
        };

        // Helper function to show usage instructions
        window.showUsageInstructions = function() {
            console.log('=== Twitch Event Overlay Usage ===');
            console.log('1. Use URL format: /twitchevent.html#YOUR_USER_ID');
            console.log('2. Replace YOUR_USER_ID with your actual Firebase user ID');
            console.log('3. The overlay will automatically load events for that user');
            console.log('4. No login required - events are loaded based on the hashtag');
            console.log('5. Call testAlert("Name") to test the alert display');
            console.log('================================');
        };

        // Test all event types
        window.testAllAlerts = function(name = 'TestUser') {
            const eventTypes = ['channel.follow', 'channel.subscribe', 'channel.cheer', 'channel.raid'];
            eventTypes.forEach((eventType, index) => {
                setTimeout(() => {
                    window.showTestAlert(name, eventType);
                }, index * 3000); // 3 second delay between each alert
            });
        };

        console.log('Twitch Event Overlay initialized');
        console.log('Using hashtag-based user identification - no login required');
        console.log('Available test functions:');
        console.log('  showTestAlert("YourName") - Test a follow alert');
        console.log('  showTestAlert("YourName", "channel.subscribe") - Test a subscription alert');
        console.log('  showTestAlert("YourName", "channel.cheer") - Test a cheer alert');
        console.log('  showTestAlert("YourName", "channel.raid") - Test a raid alert');
        console.log('  testAllAlerts("YourName") - Test all alert types sequentially');
        console.log('Call showUsageInstructions() for usage details');
        console.log('Call testAlert("YourName") in the console to test an alert');
    </script>
</body>
</html>
