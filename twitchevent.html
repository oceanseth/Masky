<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Event Overlay</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: transparent;
            overflow: hidden;
            position: relative;
        }

        /* Transparent background for OBS */
        .transparent-bg {
            background: transparent !important;
            pointer-events: none;
        }

        /* Alert overlay container */
        .alert-overlay {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100vw;
        }

        /* Custom alert message styles */
        .custom-alert {
            transform: translateY(0);
            transition: all 0.3s ease;
        }

        /* Legacy follow alert for backward compatibility */
        .follow-alert {
            background: linear-gradient(135deg, #c084fc 0%, #9333ea 100%);
            color: white;
            padding: 2rem 3rem;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(147, 51, 234, 0.5);
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            animation: fadeIn 5s ease-in, fadeOut 5s ease-out 5s;
            opacity: 0;
            white-space: nowrap;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        @keyframes alertSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes alertSlideOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* Loading state */
        .loading {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(192, 132, 252, 0.6);
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 10px;
            height: 10px;
            margin-left: 8px;
            border: 2px solid rgba(192, 132, 252, 0.6);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error state */
        .error {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #ef4444;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            max-width: 400px;
        }

        /* Success state */
        .connected {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #22c55e;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .connected::before {
            content: 'âœ“ ';
            margin-right: 4px;
        }

    </style>
</head>
<body class="transparent-bg">
    <!-- Alert Overlay Container -->
    <div class="alert-overlay" id="alertOverlay"></div>
    <!-- Video Overlay Container -->
    <div class="alert-overlay" id="videoOverlay" style="z-index: 2000;"></div>

    <!-- Status Indicator -->
    <div class="loading" id="statusIndicator">Waiting for events...</div>


    <script>
        // Test function accessible from console
        window.testAlert = function(name = 'TestUser') {
            // This will be set by the module after it loads
            if (window.showTestAlert) {
                window.showTestAlert(name);
            } else {
                console.error('showTestAlert not available yet. Wait for page to load.');
            }
        };
    </script>

    <script type="module">
        import { db, collection, doc, query, onSnapshot } from '/src/firebase.js';
        import { config } from '/src/config.js';

        // Initialize event listeners
        let unsubscribeEvents = null;
        let unsubscribeDeploymentListener = null;
        let currentUserId = null;
        let projectConfigs = new Map();
        let eventVideoCache = new Map();
        let preloadedVideoElements = new Map();
        let videoEntryIndex = new Map();
        let eventConfigSnapshot = null;
        let cachedEventTypes = [];
        let processedEventDocIds = new Map();
        let activeEventListenerKeys = new Set();
        let lastConfigFetchTime = 0;
        let configFetchPromise = null;
        let currentlyPlayingVideo = null;
        let pendingReload = false;
        let lastDeploymentEventId = null;
        const CONFIG_REFRESH_MIN_INTERVAL_MS = 15000;
        const HEYGEN_EXPIRY_BUFFER_MS = 15000;

        // Extract userId from URL hash
        function getUserIdFromHash() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#')) {
                const userId = hash.substring(1); // Remove the # symbol
                console.log('Extracted user ID from hash:', userId);
                return userId;
            }
            console.log('No user ID found in URL hash. Expected format: #userId');
            return null;
        }

        // Initialize the overlay
        async function initializeOverlay() {
            const statusIndicator = document.getElementById('statusIndicator');
            
            // Get userId from hash
            currentUserId = getUserIdFromHash();
            
            if (!currentUserId) {
                statusIndicator.textContent = 'No user ID found in URL hash';
                statusIndicator.className = 'error';
                return;
            }
            
            statusIndicator.textContent = 'Connecting...';
            statusIndicator.className = 'loading';
            
            try {
                const { eventTypes } = await loadUserProjects({ initial: true, force: true });
                if (!eventTypes || !eventTypes.length) {
                    statusIndicator.textContent = 'No active Twitch projects found';
                    statusIndicator.className = 'error';
                    statusIndicator.style.display = 'block';
                    console.log('No active Twitch event configurations returned from backend.');
                } else {
                    statusIndicator.style.display = 'none';
                    console.log('Connected - Waiting for events', { eventTypes });
                }
            } catch (error) {
                console.error('Error loading projects:', error);
                statusIndicator.textContent = 'Error: ' + error.message;
                statusIndicator.className = 'error';
            }
        }

        // Cleanup function
        function cleanup() {
            if (unsubscribeEvents) {
                unsubscribeEvents.forEach(unsubscribe => {
                    if (typeof unsubscribe === 'function') {
                        unsubscribe();
                    }
                });
                unsubscribeEvents = null;
            }
            if (unsubscribeDeploymentListener && typeof unsubscribeDeploymentListener === 'function') {
                unsubscribeDeploymentListener();
                unsubscribeDeploymentListener = null;
            }
            activeEventListenerKeys = new Set();
            processedEventDocIds = new Map();
        }

        // Setup deployment listener to detect when new version is deployed
        function setupDeploymentListener() {
            // Path: _system/deployments/events
            const systemDocRef = doc(db, '_system', 'deployments');
            const eventsCollectionRef = collection(systemDocRef, 'events');
            const q = query(eventsCollectionRef);
            
            console.log('Setting up deployment listener...');
            
            unsubscribeDeploymentListener = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const deploymentData = change.doc.data();
                        const docId = change.doc.id;
                        
                        // Skip if this is the same event we already processed
                        if (lastDeploymentEventId === docId) {
                            return;
                        }
                        
                        lastDeploymentEventId = docId;
                        console.log('New deployment detected:', {
                            version: deploymentData.version,
                            branch: deploymentData.branch,
                            timestamp: deploymentData.timestamp
                        });
                        
                        // Trigger reload after current video finishes
                        triggerReloadAfterVideo();
                    }
                });
            }, (error) => {
                console.error('Error listening to deployment events:', error);
            });
        }

        // Trigger reload after current video finishes playing
        function triggerReloadAfterVideo() {
            if (pendingReload) {
                console.log('Reload already pending, skipping...');
                return;
            }
            
            pendingReload = true;
            console.log('Deployment detected - will reload after current video finishes');
            
            // Check if video is currently playing
            if (currentlyPlayingVideo && !currentlyPlayingVideo.paused && !currentlyPlayingVideo.ended) {
                console.log('Video is currently playing, waiting for it to finish...');
                
                const onVideoEnd = () => {
                    console.log('Video finished, reloading page...');
                    currentlyPlayingVideo.removeEventListener('ended', onVideoEnd);
                    currentlyPlayingVideo.removeEventListener('error', onVideoEnd);
                    currentlyPlayingVideo = null;
                    performReload();
                };
                
                currentlyPlayingVideo.addEventListener('ended', onVideoEnd, { once: true });
                currentlyPlayingVideo.addEventListener('error', onVideoEnd, { once: true });
            } else {
                // No video playing, reload immediately
                console.log('No video playing, reloading immediately...');
                performReload();
            }
        }

        // Perform the actual reload with cache busting
        function performReload() {
            // Force reload with cache busting
            const url = new URL(window.location.href);
            url.searchParams.set('_reload', Date.now().toString());
            window.location.href = url.toString();
        }

        // Reset reload flag if page was reloaded with cache busting parameter
        if (new URLSearchParams(window.location.search).has('_reload')) {
            pendingReload = false;
            console.log('Page reloaded with cache busting parameter');
        }

        // Initialize on page load
        initializeOverlay();
        
        // Setup deployment listener (no userId needed for system events)
        // This listens to global deployment events, not user-specific events
        setupDeploymentListener();

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);

        const CHANNEL_POINTS_EVENT_TYPES = new Set([
            'channel.channel_points_custom_reward_redemption',
            'channel.channel_points_custom_reward_redemption.add'
        ]);

        function normalizeEventType(eventType) {
            if (!eventType) return eventType;
            if (eventType === 'channel.channel_points_custom_reward_redemption') {
                return 'channel.channel_points_custom_reward_redemption.add';
            }
            return eventType;
        }

        function getEventTypeVariants(eventType) {
            const normalized = normalizeEventType(eventType);
            const variants = new Set([eventType, normalized]);
            if (normalized === 'channel.channel_points_custom_reward_redemption.add') {
                variants.add('channel.channel_points_custom_reward_redemption');
            }
            return Array.from(variants);
        }

        function isChannelPointsEvent(eventType) {
            return CHANNEL_POINTS_EVENT_TYPES.has(eventType);
        }

        function parseExpiresAt(value) {
            if (!value) return null;
            if (typeof value === 'number') {
                return value > 1e12 ? value : value * 1000;
            }
            if (value instanceof Date) {
                return value.getTime();
            }
            if (typeof value === 'string') {
                const numeric = Number(value);
                if (!Number.isNaN(numeric)) {
                    return numeric > 1e12 ? numeric : numeric * 1000;
                }
                const parsed = Date.parse(value);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
            }
            return null;
        }

        function buildVideoEntryKey(eventType, projectId, type, videoId) {
            return [
                normalizeEventType(eventType) || 'unknown',
                projectId || 'unknown',
                type || 'unknown',
                videoId || 'none'
            ].join('::');
        }

        // eventKey is in format "platform:eventType"
        function findVideoCacheEntry(eventKey, projectId, type, videoId) {
            const key = buildVideoEntryKey(eventKey, projectId, type, videoId);
            return videoEntryIndex.get(key) || null;
        }

        function applyUserEventConfiguration(config) {
            eventConfigSnapshot = config;
            projectConfigs = new Map();
            eventVideoCache = new Map();
            videoEntryIndex = new Map();

            if (!config || !config.providers || Object.keys(config.providers).length === 0) {
                cachedEventTypes = [];
                return { eventTypes: [], projectCount: 0 };
            }

            // Process projects from all platforms
            const providers = config.providers || {};
            const eventTypes = new Set();
            const platformEventTypes = new Map(); // Map to track platform for each event type
            let projectCount = 0;

            // Iterate over all platforms
            Object.entries(providers).forEach(([platform, provider]) => {
                const projects = Array.isArray(provider.projects) ? provider.projects : [];
                
                projects.forEach(project => {
                    const rawEventType = project.eventType || 'channel.follow';
                    const eventType = normalizeEventType(rawEventType);
                    const eventKey = `${platform}:${eventType}`;
                    eventTypes.add(eventKey);
                    platformEventTypes.set(eventKey, { platform, eventType, rawEventType });

                    const alertConfigSource =
                        project.activeAlertConfig ||
                        project.alertConfig?.[eventType] ||
                        project.alertConfig?.[rawEventType] ||
                        getDefaultAlertConfig(eventType);

                    const alertConfig = JSON.parse(JSON.stringify(alertConfigSource || getDefaultAlertConfig(eventType)));

                    if (eventType === 'channel.channel_points_custom_reward_redemption.add') {
                        const minimumOverrideRaw = project.channelPointsMinimumCost;
                        const minimumOverride = Number.isFinite(minimumOverrideRaw)
                            ? minimumOverrideRaw
                            : Number.parseInt(minimumOverrideRaw, 10);
                        if (Number.isFinite(minimumOverride) && minimumOverride >= 0) {
                            if (!alertConfig.conditions) {
                                alertConfig.conditions = {};
                            }
                            alertConfig.conditions.minimumCost = Math.floor(minimumOverride);
                        }

                        const rewardTitleOverrideRaw = typeof project.channelPointsRewardTitle === 'string'
                            ? project.channelPointsRewardTitle.trim()
                            : '';
                        if (rewardTitleOverrideRaw && rewardTitleOverrideRaw.toLowerCase() !== 'any') {
                            if (!alertConfig.conditions) {
                                alertConfig.conditions = {};
                            }
                            alertConfig.conditions.rewardTitle = rewardTitleOverrideRaw;
                        } else if (alertConfig.conditions && Object.prototype.hasOwnProperty.call(alertConfig.conditions, 'rewardTitle')) {
                            delete alertConfig.conditions.rewardTitle;
                        }
                    }

                    if (!projectConfigs.has(eventKey)) {
                        projectConfigs.set(eventKey, []);
                    }
                    projectConfigs.get(eventKey).push({
                        projectId: project.projectId,
                        config: alertConfig,
                        rawEventType,
                        platform: platform
                    });

                    if (!eventVideoCache.has(eventKey)) {
                        eventVideoCache.set(eventKey, []);
                    }

                    const sources = Array.isArray(project.videoSources) ? project.videoSources : [];
                    if (!sources.length) {
                        console.warn(`Project ${project.projectId} (${platform}:${eventType}) has no video sources.`);
                    }

                    sources.forEach(source => {
                        const entry = {
                            projectId: project.projectId,
                            type: source.type || 'heygen',
                            videoId: source.videoId || null,
                            currentUrl: source.url || null,
                            status: source.status || null,
                            lastFetched: Date.now(),
                            expiresAt: parseExpiresAt(source.expiresAt || source.expireAt || source.expiredAt || null),
                            muted: Boolean(source.muted),
                            config: alertConfig,
                            platform: platform
                        };
                        eventVideoCache.get(eventKey).push(entry);
                        videoEntryIndex.set(buildVideoEntryKey(eventKey, entry.projectId, entry.type, entry.videoId), entry);
                    });

                    projectCount += 1;
                });
            });

            cachedEventTypes = Array.from(eventTypes);

            console.groupCollapsed('[Overlay] Applied backend configuration');
            try {
                console.log('User:', config.userId);
                console.log('Generated at:', config.generatedAt);
                console.log('Event types:', cachedEventTypes);
                console.log('Projects:', projectCount);
            } finally {
                console.groupEnd();
            }

            return { eventTypes: cachedEventTypes, projectCount };
        }

        async function fetchUserEventConfiguration(userId) {
            const trimmedBase = (config?.api?.baseUrl || '').replace(/\/$/, '');
            const endpoint = trimmedBase ? `${trimmedBase}/api/users/events` : '/api/users/events';
            const requestUrl = `${endpoint}?userId=${encodeURIComponent(userId)}`;

            const response = await fetch(requestUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                    'Cache-Control': 'no-store'
                },
                cache: 'no-store'
            });

            if (!response.ok) {
                const message = `Failed to load user events (${response.status})`;
                throw new Error(message);
            }

            return await response.json();
        }

        async function refreshUserProjects(options = {}) {
            const { force = false, preload = false } = options;
            if (!currentUserId) {
                return { config: null, eventTypes: [] };
            }

            const now = Date.now();
            const shouldUseCache = !force && eventConfigSnapshot && (now - lastConfigFetchTime) < CONFIG_REFRESH_MIN_INTERVAL_MS;

            if (shouldUseCache) {
                const cachedResult = { config: eventConfigSnapshot, eventTypes: cachedEventTypes.slice() };
                ensureEventListeners(cachedResult.eventTypes);
                if (preload) {
                    preloadedVideoElements = new Map();
                    await preloadAllEventVideos();
                }
                return cachedResult;
            }

            if (configFetchPromise) {
                const result = await configFetchPromise;
                ensureEventListeners(result.eventTypes);
                if (preload) {
                    preloadedVideoElements = new Map();
                    await preloadAllEventVideos();
                }
                return result;
            }

            const fetchPromise = (async () => {
                const config = await fetchUserEventConfiguration(currentUserId);
                lastConfigFetchTime = Date.now();
                const applyResult = applyUserEventConfiguration(config);
                const result = { config, eventTypes: applyResult.eventTypes };
                ensureEventListeners(result.eventTypes);
                if (preload) {
                    preloadedVideoElements = new Map();
                    await preloadAllEventVideos();
                }
                return result;
            })().finally(() => {
                configFetchPromise = null;
            });

            configFetchPromise = fetchPromise;
            return fetchPromise;
        }

        function ensureEventListeners(eventTypes = []) {
            // eventTypes are now in format "platform:eventType"
            eventTypes
                .filter(Boolean)
                .forEach(eventTypeKey => {
                    if (!activeEventListenerKeys.has(eventTypeKey)) {
                        setupEventListener(eventTypeKey);
                    }
                });
        }

        async function loadUserProjects(options = {}) {
            const { initial = false, force = false } = options;
            if (!currentUserId) {
                return { eventTypes: [] };
            }

            if (initial) {
                cleanup();
            }

            const refreshResult = await refreshUserProjects({
                force: force || initial,
                preload: initial
            });

            const eventTypes = refreshResult.eventTypes || [];
            ensureEventListeners(eventTypes);

            return { eventTypes };
        }

        // eventKey is in format "platform:eventType"
        async function resolveVideoUrl(cacheEntry, eventKey, options = {}) {
            if (!cacheEntry) return null;
            const allowRefresh = options?.allowRefresh !== false;

            if (cacheEntry.type === 'uploaded') {
                return cacheEntry.currentUrl || cacheEntry.videoUrl || null;
            }

            const now = Date.now();
            if (cacheEntry.currentUrl) {
                const expiresAt = cacheEntry.expiresAt;
                if (!expiresAt || expiresAt - HEYGEN_EXPIRY_BUFFER_MS > now) {
                    return cacheEntry.currentUrl;
                }
            }

            if (!allowRefresh) {
                return cacheEntry.currentUrl || null;
            }

            await refreshUserProjects({ force: true, preload: false });

            // Use eventKey from cacheEntry if available, otherwise use provided eventKey
            const lookupKey = cacheEntry.platform ? `${cacheEntry.platform}:${cacheEntry.eventType || eventKey.split(':')[1]}` : eventKey;
            const updated = findVideoCacheEntry(lookupKey, cacheEntry.projectId, cacheEntry.type, cacheEntry.videoId);
            if (updated) {
                Object.assign(cacheEntry, updated);
            }

            return cacheEntry.currentUrl || null;
        }

        // Preload all videos into detached video elements to warm cache
        async function preloadAllEventVideos() {
            preloadedVideoElements = new Map();
            for (const [eventKey, items] of eventVideoCache.entries()) {
                // eventKey is in format "platform:eventType"
                console.groupCollapsed(`Preloading videos for ${eventKey}`);
                const list = [];
                await Promise.all(items.map(async (item) => {
                    try {
                        const videoUrl = await resolveVideoUrl(item, eventKey, { allowRefresh: false });
                        if (!videoUrl) {
                            console.warn('No video URL available for preloading', {
                                projectId: item.projectId,
                                videoId: item.videoId,
                                type: item.type
                            });
                            return;
                        }
                        const v = document.createElement('video');
                        v.src = videoUrl;
                        v.preload = 'auto';
                        v.muted = true; // allow autoplay preloading
                        v.load();
                        list.push({ projectId: item.projectId, el: v, url: videoUrl });
                        console.log('Preloading URL:', videoUrl, 'projectId:', item.projectId);
                    } catch (e) {
                        console.warn('Failed to preload video for project', item.projectId, e);
                    }
                }));
                preloadedVideoElements.set(eventKey, list);
                console.groupEnd();
            }
            console.log('Preloaded HeyGen videos by event key:',
                Object.fromEntries(Array.from(preloadedVideoElements.entries()).map(([key, list]) => [key, list.length])));
        }

        // Get default alert configuration for an event type
        function getDefaultAlertConfig(eventType) {
            const channelPointsDefault = {
                enabled: true,
                message: '{username} redeemed {reward} for {cost} points!',
                backgroundColor: '#8b5cf6',
                textColor: '#ffffff',
                fontSize: '2rem',
                fontWeight: '700',
                duration: 5000,
                position: 'bottom',
                conditions: {
                    minimumCost: 0,
                    maximumCost: null,
                    specificRewardIds: [] // Empty = all rewards, or specify reward IDs
                }
            };

            const defaults = {
                'channel.follow': {
                    enabled: true,
                    message: '{username} just followed!',
                    backgroundColor: '#c084fc',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                },
                'channel.chat_command': {
                    enabled: true,
                    message: 'Playing {command}!',
                    backgroundColor: '#0ea5e9',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                },
                'channel.subscribe': {
                    enabled: true,
                    message: '{username} just subscribed!',
                    backgroundColor: '#22c55e',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom'
                },
                'channel.cheer': {
                    enabled: true,
                    message: '{username} cheered {bits} bits!',
                    backgroundColor: '#f59e0b',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom',
                    conditions: {
                        minimumBits: 1,
                        maximumBits: null // null = no maximum
                    }
                },
                'channel.raid': {
                    enabled: true,
                    message: '{username} is raiding with {viewers} viewers!',
                    backgroundColor: '#ef4444',
                    textColor: '#ffffff',
                    fontSize: '2rem',
                    fontWeight: '700',
                    duration: 5000,
                    position: 'bottom',
                    conditions: {
                        minimumViewers: 1,
                        maximumViewers: null
                    }
                },
                'channel.channel_points_custom_reward_redemption': channelPointsDefault,
                'channel.channel_points_custom_reward_redemption.add': channelPointsDefault
            };

            const normalized = normalizeEventType(eventType);
            return defaults[eventType] || defaults[normalized] || defaults['channel.follow'];
        }

        // Set up real-time listener for a specific event type key
        // eventTypeKey format: "platform:eventType" (e.g., "twitch:channel.follow" or "masky:donation")
        function setupListenerForType(eventTypeKey) {
            // Parse platform and eventType from eventTypeKey
            const [platform, eventType] = eventTypeKey.includes(':') 
                ? eventTypeKey.split(':', 2) 
                : ['twitch', eventTypeKey]; // Fallback to twitch for backward compatibility
            
            // Determine the Firestore path based on platform
            // Use doc() and collection() to properly construct paths, handling user IDs with special characters
            const userDocRef = doc(db, 'users', currentUserId);
            const eventsCollectionRef = collection(userDocRef, 'events');
            
            let eventTypeDocId;
            if (platform === 'masky' && eventType === 'donation') {
                // For Masky donations, use donation directly (no platform prefix)
                eventTypeDocId = 'donation';
            } else if (platform === 'twitch') {
                // For Twitch events, use twitch_ prefix
                eventTypeDocId = `twitch_${eventType}`;
            } else {
                // For other platforms, use platform_eventType format
                eventTypeDocId = `${platform}_${eventType}`;
            }
            
            // Construct the path: users/{userId}/events/{eventType}/alerts
            const eventTypeDocRef = doc(eventsCollectionRef, eventTypeDocId);
            const alertsRef = collection(eventTypeDocRef, 'alerts');
            
            // Construct path string for logging
            const eventsCollectionPath = `users/${currentUserId}/events/${eventTypeDocId}/alerts`;
            
            // Listen to all new documents - don't filter by timestamp to avoid missing events
            // that arrive just before the listener starts. onSnapshot with docChanges() 
            // will only fire for new documents added after the listener is established.
            const q = query(alertsRef);
            
            console.log(`Setting up listener for event type: ${eventTypeKey} at path: ${eventsCollectionPath}`);
            
            if (!processedEventDocIds.has(eventTypeKey)) {
                processedEventDocIds.set(eventTypeKey, new Set());
            }
            const processedIds = processedEventDocIds.get(eventTypeKey);
            let isInitialSnapshot = true;

            const unsubscribe = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const alertData = change.doc.data();
                        const docId = change.doc.id;

                        if (isInitialSnapshot) {
                            processedIds.add(docId);
                            return;
                        }

                        if (processedIds.has(docId)) {
                            return;
                        }

                        processedIds.add(docId);

                        // For donation events, type is stored as 'donation', not 'eventType'
                        // For Twitch events, eventType is stored in eventType field
                        const incomingEventType = alertData?.eventType || alertData?.type || eventType;
                        // Normalize event type but preserve platform context
                        alertData.eventType = normalizeEventType(incomingEventType);
                        // Store the full event key for matching with projects
                        alertData.eventKey = eventTypeKey;
                        alertData.platform = platform;
                        
                        // For donation events, ensure type is set correctly
                        if (platform === 'masky' && eventType === 'donation') {
                            alertData.type = 'donation';
                            alertData.eventType = 'donation';
                        }

                        console.log(`New alert received for ${eventTypeKey}:`, alertData);
                        // Try to play Heygen video for this event; fallback to text alert
                        playVideoOrShowAlert(alertData);
                    }
                });
                isInitialSnapshot = false;
            }, (error) => {
                console.error(`Error listening to events for ${eventTypeKey}:`, error);
            });

            // Store unsubscribe function for cleanup
            if (!unsubscribeEvents) {
                unsubscribeEvents = [];
            }
            unsubscribeEvents.push(unsubscribe);
        }

        function setupEventListener(eventTypeKey) {
            // eventTypeKey is now in format "platform:eventType"
            // For Twitch events, also handle variants (e.g., channel.channel_points_custom_reward_redemption)
            if (eventTypeKey.startsWith('twitch:')) {
                const eventType = eventTypeKey.split(':', 2)[1];
                const variants = getEventTypeVariants(eventType);
                variants.forEach(variant => {
                    const variantKey = `twitch:${variant}`;
                    if (activeEventListenerKeys.has(variantKey)) {
                        return;
                    }
                    activeEventListenerKeys.add(variantKey);
                    setupListenerForType(variantKey);
                });
            } else {
                // For non-Twitch events (like masky:donation), just set up listener directly
                if (activeEventListenerKeys.has(eventTypeKey)) {
                    return;
                }
                activeEventListenerKeys.add(eventTypeKey);
                setupListenerForType(eventTypeKey);
            }
        }

        // Play a random preloaded Heygen video for the given event type
        // eventKey is in format "platform:eventType" (e.g., "twitch:channel.follow" or "masky:donation")
        async function playHeygenVideoForEvent(eventKey, eventData = null) {
            const items = eventVideoCache.get(eventKey) || [];
            if (!items.length) {
                console.log(`No videos cached for event key: ${eventKey}`);
                return false;
            }

            // Extract eventType for normalization and config lookup
            const [, eventType] = eventKey.includes(':') ? eventKey.split(':', 2) : ['twitch', eventKey];
            const normalizedEventType = normalizeEventType(eventType);

            const eligibleItems = items.filter(item => {
                const cfg = item?.config || getDefaultAlertConfig(normalizedEventType);
                if (!cfg.enabled) return false;
                if (eventData && !meetsConditions(normalizedEventType, eventData, cfg)) return false;
                return true;
            });

            if (!eligibleItems.length) {
                console.log(`No eligible videos (after filtering by config/conditions) for event key: ${eventKey}`);
                return false;
            }

            const randomIndex = Math.floor(Math.random() * eligibleItems.length);
            const selected = eligibleItems[randomIndex];
            const selectedConfig = selected?.config || getDefaultAlertConfig(normalizedEventType);
            const videoUrl = await resolveVideoUrl(selected, eventKey);
            if (!videoUrl) {
                console.warn(`No playable video URL available for event key: ${eventKey}`, {
                    projectId: selected.projectId,
                    videoId: selected.videoId,
                    lastStatus: selected.lastStatus
                });
                return false;
            }
            const shouldMute = Boolean(selected.muted);
            
            // Check for preloaded video element
            const preloadedList = preloadedVideoElements?.get(eventKey) || [];
            const preloadedEntry = preloadedList.find(x => x.url === videoUrl && x.projectId === selected.projectId);
            
            console.log(`ðŸŽ² Random video selection for ${eventKey}:`);
            console.log(`  - Available videos: ${items.length}`);
            console.log(`  - Eligible videos: ${eligibleItems.length}`);
            console.log(`  - Random index: ${randomIndex}`);
            console.log(`  - Selected project: ${selected.projectId}`);
            console.log(`  - Video type: ${selected.type}`);
            console.log(`  - Video ID: ${selected.videoId || 'N/A'}`);
            console.log(`  - Video URL: ${videoUrl}`);
            console.log(`  - Muted: ${shouldMute}`);
            console.log(`  - Preloaded: ${preloadedEntry ? 'Yes' : 'No'}`);

            const overlay = document.getElementById('videoOverlay');
            overlay.innerHTML = '';

            const videoContainer = document.createElement('div');
            videoContainer.style.position = 'relative';
            videoContainer.style.display = 'flex';
            videoContainer.style.flexDirection = 'column';
            videoContainer.style.alignItems = 'center';
            videoContainer.style.justifyContent = 'center';
            videoContainer.style.maxWidth = '90vw';
            videoContainer.style.maxHeight = '90vh';

            // Create a new video element (browser cache will handle preloaded videos)
            const video = document.createElement('video');
            video.src = videoUrl;
            video.autoplay = true;
            video.controls = false;
            video.playsInline = true;
            video.muted = shouldMute;
            video.style.maxWidth = '90vw';
            video.style.maxHeight = '90vh';
            video.style.borderRadius = '12px';
            video.style.boxShadow = '0 10px 40px rgba(0,0,0,0.5)';
            video.style.pointerEvents = 'none';
            
            // Track currently playing video for deployment reload logic
            currentlyPlayingVideo = video;

            let messageElement = null;
            if (selectedConfig.message) {
                let message = selectedConfig.message;
                // For donation events, data is on alertData directly, not in eventData
                const dataSource = normalizedEventType === 'donation' ? (alertData || {}) : (eventData || {});
                message = message.replace('{username}', dataSource.user_name || dataSource.donorName || dataSource.from_broadcaster_user_name || 'Someone');

                if (normalizedEventType === 'channel.cheer') {
                    message = message.replace('{bits}', dataSource.bits || '0');
                } else if (normalizedEventType === 'channel.raid') {
                    message = message.replace('{viewers}', dataSource.viewers || '0');
                } else if (isChannelPointsEvent(normalizedEventType)) {
                    message = message.replace('{reward}', dataSource.reward?.title || 'Custom Reward');
                    message = message.replace('{cost}', dataSource.reward?.cost || '0');
                } else if (normalizedEventType === 'channel.chat_command') {
                    message = message.replace('{command}', dataSource.command || 'command');
                } else if (normalizedEventType === 'donation') {
                    // Handle donation message placeholders
                    message = message.replace('{amount}', alertData.amount ? `$${alertData.amount.toFixed(2)}` : '$0.00');
                    message = message.replace('{donor}', alertData.donorName || 'Anonymous');
                }

                messageElement = document.createElement('div');
                messageElement.textContent = message;
                messageElement.style.cssText = `
                    background: ${selectedConfig.backgroundColor};
                    color: ${selectedConfig.textColor};
                    font-size: ${selectedConfig.fontSize};
                    font-weight: ${selectedConfig.fontWeight};
                    padding: 1rem 2rem;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                    text-align: center;
                    font-family: 'Orbitron', sans-serif;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                    max-width: 80%;
                    word-wrap: break-word;
                    white-space: normal;
                    pointer-events: none;
                    margin-top: 1rem;
                `;
            }

            const tryPlay = async () => {
                try {
                    await video.play();
                } catch (err) {
                    console.warn('Autoplay blocked, retrying muted', err);
                    try {
                        video.muted = true;
                        await video.play();
                        if (!shouldMute) {
                            video.muted = false;
                        }
                    } catch (err2) {
                        console.error('Video play failed', err2);
                    }
                }
            };

            videoContainer.appendChild(video);
            if (messageElement) {
                videoContainer.appendChild(messageElement);
            }

            overlay.appendChild(videoContainer);

            // Note: Browser cache will handle preloaded videos automatically
            // The preloadedEntry is just for logging purposes
            if (preloadedEntry) {
                console.log('Video is preloaded and should load quickly from cache');
            }
            
            const cleanupVideo = () => {
                // Clear currently playing video reference
                if (currentlyPlayingVideo === video) {
                    currentlyPlayingVideo = null;
                }
                
                if (videoContainer && videoContainer.parentNode) {
                    videoContainer.parentNode.removeChild(videoContainer);
                }
                
                // If reload was pending and video finished, trigger reload now
                if (pendingReload && !currentlyPlayingVideo) {
                    console.log('Video cleanup complete, performing pending reload...');
                    performReload();
                }
            };
            
            video.addEventListener('ended', cleanupVideo, { once: true });
            video.addEventListener('error', () => {
                console.error('Error during video playback for', normalizedEventType, {
                    projectId: selected.projectId,
                    videoId: selected.videoId,
                    videoUrl
                });
                cleanupVideo();
            }, { once: true });

            await tryPlay();
            return true;
        }

        function playVideoOrShowAlert(alertData) {
            // Use eventKey if available (format: "platform:eventType"), otherwise fallback to eventType
            const eventKey = alertData?.eventKey || (alertData?.platform && alertData?.eventType 
                ? `${alertData.platform}:${alertData.eventType}` 
                : null);
            const eventType = alertData?.eventType;
            // For donation events, data is on alertData directly, not in eventData
            // For Twitch events, data is in eventData
            const eventData = alertData?.eventData || (alertData?.type === 'donation' ? alertData : null);
            
            // If no eventKey or eventType, use default
            if (!eventKey && !eventType) {
                console.warn('playVideoOrShowAlert called without a valid eventType or eventKey', alertData);
                showAlert(alertData);
                return Promise.resolve(false);
            }
            
            // Use eventKey if available, otherwise construct from platform and eventType
            const finalEventKey = eventKey || (alertData?.platform ? `${alertData.platform}:${eventType}` : `twitch:${eventType}`);
            const normalizedEventType = normalizeEventType(eventType);
            alertData.eventType = normalizedEventType;
            alertData.eventKey = finalEventKey;
            
            return playHeygenVideoForEvent(finalEventKey, eventData, alertData)
                .then(played => {
                    if (!played) {
                        showAlert(alertData);
                    }
                    return played;
                })
                .catch(err => {
                    console.error(`Failed to play HeyGen video for ${finalEventKey}:`, err);
                    showAlert(alertData);
                    return false;
                });
        }

        // Check if event meets the configured conditions
        function meetsConditions(eventType, eventData, config) {
            const normalizedEventType = normalizeEventType(eventType);
            const conditions = config.conditions;
            if (!conditions) return true; // No conditions = always trigger

            // Check cheer bit conditions
            if (normalizedEventType === 'channel.cheer' && eventData.bits !== undefined) {
                const bits = parseInt(eventData.bits) || 0;
                
                if (conditions.minimumBits && bits < conditions.minimumBits) {
                    console.log(`Cheer ${bits} bits below minimum ${conditions.minimumBits}, skipping alert`);
                    return false;
                }
                
                if (conditions.maximumBits && bits > conditions.maximumBits) {
                    console.log(`Cheer ${bits} bits above maximum ${conditions.maximumBits}, skipping alert`);
                    return false;
                }
            }
            
            // Check raid viewer conditions
            if (normalizedEventType === 'channel.raid' && eventData.viewers !== undefined) {
                const viewers = parseInt(eventData.viewers) || 0;
                
                if (conditions.minimumViewers && viewers < conditions.minimumViewers) {
                    console.log(`Raid ${viewers} viewers below minimum ${conditions.minimumViewers}, skipping alert`);
                    return false;
                }
                
                if (conditions.maximumViewers && viewers > conditions.maximumViewers) {
                    console.log(`Raid ${viewers} viewers above maximum ${conditions.maximumViewers}, skipping alert`);
                    return false;
                }
            }
            
            // Check channel points conditions
            if (isChannelPointsEvent(normalizedEventType)) {
                const cost = parseInt(eventData.reward?.cost) || 0;
                const rewardId = eventData.reward?.id;
                const rewardTitle = (eventData.reward?.title || '').trim();
                
                if (conditions.minimumCost && cost < conditions.minimumCost) {
                    console.log(`Channel points ${cost} below minimum ${conditions.minimumCost}, skipping alert`);
                    return false;
                }
                
                if (conditions.maximumCost && cost > conditions.maximumCost) {
                    console.log(`Channel points ${cost} above maximum ${conditions.maximumCost}, skipping alert`);
                    return false;
                }
                
                // Check if specific reward IDs are configured
                if (conditions.specificRewardIds && conditions.specificRewardIds.length > 0) {
                    if (!conditions.specificRewardIds.includes(rewardId)) {
                        console.log(`Reward ID ${rewardId} not in allowed list, skipping alert`);
                        return false;
                    }
                }

                if (conditions.rewardTitle && typeof conditions.rewardTitle === 'string') {
                    const configuredTitle = conditions.rewardTitle.trim().toLowerCase();
                    if (configuredTitle && rewardTitle.toLowerCase() !== configuredTitle) {
                        console.log(`Reward title "${rewardTitle || '(none)'}" does not match required title "${conditions.rewardTitle}", skipping alert`);
                        return false;
                    }
                }

                if (Array.isArray(conditions.rewardTitles) && conditions.rewardTitles.length > 0) {
                    const normalizedTitles = conditions.rewardTitles
                        .filter(title => typeof title === 'string' && title.trim())
                        .map(title => title.trim().toLowerCase());
                    if (normalizedTitles.length > 0 && !normalizedTitles.includes(rewardTitle.toLowerCase())) {
                        console.log(`Reward title "${rewardTitle || '(none)'}" not in allowed list, skipping alert`);
                        return false;
                    }
                }
            }
            
            return true;
        }

        // Display alert on screen
        function showAlert(alertData) {
            const { eventType, eventData, eventKey } = alertData;
            const normalizedEventType = normalizeEventType(eventType);
            
            // For donation events, data is on alertData directly, not in eventData
            // For Twitch events, data is in eventData
            const dataSource = normalizedEventType === 'donation' ? alertData : (eventData || {});
            
            // Use eventKey if available, otherwise try to match by eventType
            const finalEventKey = eventKey || (alertData?.platform ? `${alertData.platform}:${eventType}` : `twitch:${eventType}`);
            const configEntries = projectConfigs.get(finalEventKey) || projectConfigs.get(normalizedEventType) || projectConfigs.get(eventType) || [];
            const eligibleConfigs = configEntries
                .map(entry => entry?.config || entry)
                .filter(cfg => cfg && cfg.enabled && meetsConditions(normalizedEventType, dataSource, cfg));

            let config;
            if (eligibleConfigs.length) {
                config = eligibleConfigs[Math.floor(Math.random() * eligibleConfigs.length)];
            } else {
                const fallbackConfig = getDefaultAlertConfig(normalizedEventType);
                if (!fallbackConfig.enabled || !meetsConditions(normalizedEventType, dataSource, fallbackConfig)) {
                    console.log(`Alert disabled or conditions not met for event type: ${normalizedEventType}`);
                    return;
                }
                config = fallbackConfig;
            }
            
            // Build message from template
            let message = config.message;
            
            // Replace placeholders with actual data
            message = message.replace('{username}', dataSource.user_name || dataSource.donorName || dataSource.from_broadcaster_user_name || 'Someone');
            
            // Handle event-specific placeholders
            if (normalizedEventType === 'channel.cheer') {
                message = message.replace('{bits}', dataSource.bits || '0');
            } else if (normalizedEventType === 'channel.raid') {
                message = message.replace('{viewers}', dataSource.viewers || '0');
            } else if (isChannelPointsEvent(normalizedEventType)) {
                message = message.replace('{reward}', dataSource.reward?.title || 'Custom Reward');
                message = message.replace('{cost}', dataSource.reward?.cost || '0');
            } else if (normalizedEventType === 'channel.chat_command') {
                message = message.replace('{command}', dataSource.command || 'command');
            } else if (normalizedEventType === 'donation') {
                // Handle donation message placeholders
                message = message.replace('{amount}', alertData.amount ? `$${alertData.amount.toFixed(2)}` : '$0.00');
                message = message.replace('{donor}', alertData.donorName || 'Anonymous');
            }

            console.log(`Showing alert: ${message} (${normalizedEventType})`);

            // Create alert element
            const alertOverlay = document.getElementById('alertOverlay');
            const alertElement = document.createElement('div');
            
            // Apply custom styling
            alertElement.className = 'custom-alert';
            alertElement.textContent = message;
            alertElement.style.cssText = `
                background: ${config.backgroundColor};
                color: ${config.textColor};
                font-size: ${config.fontSize};
                font-weight: ${config.fontWeight};
                padding: 1.5rem 2.5rem;
                border-radius: 16px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
                text-align: center;
                animation: alertSlideIn 0.5s ease-out, alertSlideOut 0.5s ease-in ${config.duration - 500}ms;
                opacity: 1;
                white-space: nowrap;
                font-family: 'Orbitron', sans-serif;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                position: relative;
                z-index: 1000;
                max-width: 90vw;
                word-wrap: break-word;
                white-space: normal;
            `;
            
            // Position the alert
            if (config.position === 'top') {
                alertOverlay.style.top = '10%';
                alertOverlay.style.bottom = 'auto';
            } else {
                alertOverlay.style.top = 'auto';
                alertOverlay.style.bottom = '10%';
            }
            
            // Clear any existing alerts
            alertOverlay.innerHTML = '';
            alertOverlay.appendChild(alertElement);
            
            // Remove alert after specified duration
            setTimeout(() => {
                if (alertElement.parentNode) {
                    alertElement.parentNode.removeChild(alertElement);
                }
            }, config.duration);
        }

        // Expose functions to window for console access
        window.showTestAlert = function(name = 'TestUser', eventType = 'channel.follow') {
            console.log(`Testing alert with name: ${name}, event: ${eventType}`);
            
            let eventData = {
                user_name: name,
                user_id: '123456',
                broadcaster_user_id: '11867613'
            };
            
            // Add event-specific data
            if (eventType === 'channel.cheer') {
                eventData.bits = Math.floor(Math.random() * 1000) + 1;
            } else if (eventType === 'channel.raid') {
                eventData.viewers = Math.floor(Math.random() * 100) + 1;
            }
            
            const testData = {
                eventType: eventType,
                eventData: eventData
            };
            // Try to play HeyGen video for this event type first; fallback to text alert
            playVideoOrShowAlert(testData);
        };

        // Helper function to show usage instructions
        window.showUsageInstructions = function() {
            console.log('=== Twitch Event Overlay Usage ===');
            console.log('1. Use URL format: /twitchevent.html#YOUR_USER_ID');
            console.log('2. Replace YOUR_USER_ID with your actual Firebase user ID');
            console.log('3. The overlay will automatically load events for that user');
            console.log('4. No login required - events are loaded based on the hashtag');
            console.log('5. Call testAlert("Name") to test the alert display');
            console.log('================================');
        };

        // Test all event types
        window.testAllAlerts = function(name = 'TestUser') {
            const eventTypes = ['channel.follow', 'channel.subscribe', 'channel.cheer', 'channel.raid'];
            eventTypes.forEach((eventType, index) => {
                setTimeout(() => {
                    window.showTestAlert(name, eventType);
                }, index * 3000); // 3 second delay between each alert
            });
        };

        // Test random follow alerts specifically
        window.testRandomFollows = function(name = 'TestUser', count = 5) {
            console.log(`ðŸŽ¯ Testing ${count} random follow alerts...`);
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    console.log(`\n--- Random Follow Test #${i + 1} ---`);
                    window.showTestAlert(name, 'channel.follow');
                }, i * 2000); // 2 second delay between each test
            }
        };

        // Test conditional cheer alerts with different bit amounts
        window.testCheerConditions = function(name = 'TestUser') {
            const bitAmounts = [1, 100, 1000, 5000, 10000];
            console.log(`ðŸŽ¯ Testing cheer conditions with different bit amounts...`);
            
            bitAmounts.forEach((bits, index) => {
                setTimeout(() => {
                    console.log(`\n--- Testing ${bits} bits ---`);
                    const eventData = {
                        user_name: name,
                        user_id: '123456',
                        broadcaster_user_id: '11867613',
                        bits: bits
                    };
                    const testData = {
                        eventType: 'channel.cheer',
                        eventData: eventData
                    };
                    
                    // Test both video and text alert
                    playVideoOrShowAlert(testData);
                }, index * 3000);
            });
        };

        // Test channel points with different costs
        window.testChannelPoints = function(name = 'TestUser') {
            const costs = [1000, 2500, 5000, 10000, 50000];
            console.log(`ðŸŽ¯ Testing channel points with different costs...`);
            
            costs.forEach((cost, index) => {
                setTimeout(() => {
                    console.log(`\n--- Testing ${cost} point reward ---`);
                    const eventData = {
                        user_name: name,
                        user_id: '123456',
                        broadcaster_user_id: '11867613',
                        reward: {
                            id: 'test-reward-' + cost,
                            title: `${cost} Point Reward`,
                            cost: cost
                        }
                    };
                    const testData = {
                        eventType: 'channel.channel_points_custom_reward_redemption.add',
                        eventData: eventData
                    };
                    
                    // Test both video and text alert
                    playVideoOrShowAlert(testData);
                }, index * 3000);
            });
        };

        console.log('Twitch Event Overlay initialized');
        console.log('Using hashtag-based user identification - no login required');
        console.log('Available test functions:');
        console.log('  showTestAlert("YourName") - Test a follow alert');
        console.log('  showTestAlert("YourName", "channel.subscribe") - Test a subscription alert');
        console.log('  showTestAlert("YourName", "channel.cheer") - Test a cheer alert');
        console.log('  showTestAlert("YourName", "channel.raid") - Test a raid alert');
        console.log('  testAllAlerts("YourName") - Test all alert types sequentially');
        console.log('  testCheerConditions("YourName") - Test cheer alerts with different bit amounts');
        console.log('  testChannelPoints("YourName") - Test channel point alerts with different costs');
        console.log('Call showUsageInstructions() for usage details');
        console.log('Call testAlert("YourName") in the console to test an alert');
    </script>
</body>
</html>
